#!/bin/bash

# üè• Just Dance Event Hub - Health Check Script para Ubuntu
# Vers√£o: 1.0.0
# Autor: Just Dance Event Hub Team

# Par√¢metros
DOMAIN="localhost"
API_PORT=3000
FRONTEND_PORT=3000

# Processar argumentos
while [[ $# -gt 0 ]]; do
    case $1 in
        -d|--domain)
            DOMAIN="$2"
            shift 2
            ;;
        -p|--port)
            API_PORT="$2"
            shift 2
            ;;
        -f|--frontend-port)
            FRONTEND_PORT="$2"
            shift 2
            ;;
        -h|--help)
            echo "Uso: $0 [op√ß√µes]"
            echo "Op√ß√µes:"
            echo "  -d, --domain DOMINIO        Dom√≠nio para testar (padr√£o: localhost)"
            echo "  -p, --port PORTA           Porta da API (padr√£o: 3000)"
            echo "  -f, --frontend-port PORTA  Porta do frontend (padr√£o: 3000)"
            echo "  -h, --help                 Mostrar esta ajuda"
            exit 0
            ;;
        *)
            echo "Op√ß√£o desconhecida: $1"
            exit 1
            ;;
    esac
done

set -e  # Parar em caso de erro

# Cores para output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Fun√ß√£o para log colorido
log() {
    echo -e "${GREEN}[$(date +'%Y-%m-%d %H:%M:%S')] ‚úì $1${NC}"
}

warn() {
    echo -e "${YELLOW}[$(date +'%Y-%m-%d %H:%M:%S')] ‚ö† $1${NC}"
}

error() {
    echo -e "${RED}[$(date +'%Y-%m-%d %H:%M:%S')] ‚úó $1${NC}"
}

info() {
    echo -e "${BLUE}[$(date +'%Y-%m-%d %H:%M:%S')] ‚Ñπ $1${NC}"
}

# Banner
echo -e "${BLUE}"
cat << "EOF"
‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
‚ïë                    Just Dance Event Hub                      ‚ïë
‚ïë                    Health Check Ubuntu v1.0.0                ‚ïë
‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù
EOF
echo -e "${NC}"

# Vari√°veis de configura√ß√£o
APP_NAME="just-dance-hub"
APP_DIR="/opt/$APP_NAME"
DB_NAME="just_dance_hub"
SERVICE_USER="$APP_NAME"

# Fun√ß√£o para verificar se a aplica√ß√£o est√° instalada
check_installation() {
    info "Verificando instala√ß√£o da aplica√ß√£o..."
    
    if [ -d "$APP_DIR" ]; then
        log "Diret√≥rio da aplica√ß√£o encontrado: $APP_DIR"
        
        # Verificar arquivos essenciais
        if [ -f "$APP_DIR/.env" ]; then
            log "Arquivo .env encontrado"
        else
            error "Arquivo .env n√£o encontrado"
        fi
        
        if [ -f "$APP_DIR/ecosystem.config.js" ]; then
            log "Arquivo ecosystem.config.js encontrado"
        else
            error "Arquivo ecosystem.config.js n√£o encontrado"
        fi
        
        if [ -d "$APP_DIR/dist" ]; then
            log "Diret√≥rio dist encontrado"
        else
            error "Diret√≥rio dist n√£o encontrado"
        fi
    else
        error "Diret√≥rio da aplica√ß√£o n√£o encontrado: $APP_DIR"
        return 1
    fi
}

# Fun√ß√£o para verificar usu√°rio do sistema
check_system_user() {
    info "Verificando usu√°rio do sistema..."
    
    if id "$SERVICE_USER" &>/dev/null; then
        log "Usu√°rio $SERVICE_USER encontrado"
    else
        error "Usu√°rio $SERVICE_USER n√£o encontrado"
        return 1
    fi
}

# Fun√ß√£o para verificar PostgreSQL
check_postgresql() {
    info "Verificando PostgreSQL..."
    
    if command -v psql &> /dev/null; then
        log "PostgreSQL instalado"
        
        # Verificar se o servi√ßo est√° rodando
        if sudo systemctl is-active --quiet postgresql; then
            log "PostgreSQL est√° rodando"
        else
            error "PostgreSQL n√£o est√° rodando"
            return 1
        fi
        
        # Verificar se o banco existe
        if sudo -u postgres psql -lqt | cut -d \| -f 1 | grep -qw $DB_NAME; then
            log "Banco de dados $DB_NAME encontrado"
            
            # Testar conex√£o
            if sudo -u postgres psql -d $DB_NAME -c "SELECT 1;" &>/dev/null; then
                log "Conex√£o com banco de dados OK"
            else
                error "Falha na conex√£o com banco de dados"
                return 1
            fi
        else
            error "Banco de dados $DB_NAME n√£o encontrado"
            return 1
        fi
    else
        error "PostgreSQL n√£o instalado"
        return 1
    fi
}

# Fun√ß√£o para verificar PM2
check_pm2() {
    info "Verificando PM2..."
    
    if command -v pm2 &> /dev/null; then
        log "PM2 instalado"
        
        # Verificar se a aplica√ß√£o est√° rodando no PM2
        if sudo -u $SERVICE_USER pm2 list | grep -q $APP_NAME; then
            log "Aplica√ß√£o encontrada no PM2"
            
            # Verificar status
            STATUS=$(sudo -u $SERVICE_USER pm2 jlist | jq -r ".[] | select(.name == \"$APP_NAME\") | .pm2_env.status" 2>/dev/null || echo "unknown")
            if [ "$STATUS" = "online" ]; then
                log "Aplica√ß√£o est√° online no PM2"
            else
                warn "Aplica√ß√£o n√£o est√° online no PM2 (status: $STATUS)"
            fi
        else
            error "Aplica√ß√£o n√£o encontrada no PM2"
            return 1
        fi
    else
        error "PM2 n√£o instalado"
        return 1
    fi
}

# Fun√ß√£o para verificar Nginx
check_nginx() {
    info "Verificando Nginx..."
    
    if command -v nginx &> /dev/null; then
        log "Nginx instalado"
        
        # Verificar se o servi√ßo est√° rodando
        if sudo systemctl is-active --quiet nginx; then
            log "Nginx est√° rodando"
        else
            warn "Nginx n√£o est√° rodando"
        fi
        
        # Verificar configura√ß√£o
        if [ -f "/etc/nginx/sites-available/$APP_NAME" ]; then
            log "Configura√ß√£o do Nginx encontrada"
            
            # Testar configura√ß√£o
            if sudo nginx -t &>/dev/null; then
                log "Configura√ß√£o do Nginx OK"
            else
                warn "Problema na configura√ß√£o do Nginx"
            fi
        else
            warn "Configura√ß√£o do Nginx n√£o encontrada"
        fi
    else
        info "Nginx n√£o instalado (opcional)"
    fi
}

# Fun√ß√£o para verificar firewall
check_firewall() {
    info "Verificando firewall..."
    
    if command -v ufw &> /dev/null; then
        UFW_STATUS=$(sudo ufw status | head -1)
        if [[ $UFW_STATUS == *"Status: active"* ]]; then
            log "UFW est√° ativo"
            
            # Verificar portas
            if sudo ufw status | grep -q "22/tcp.*ALLOW"; then
                log "Porta 22 (SSH) permitida"
            else
                warn "Porta 22 (SSH) n√£o permitida"
            fi
            
            if sudo ufw status | grep -q "80/tcp.*ALLOW"; then
                log "Porta 80 (HTTP) permitida"
            else
                warn "Porta 80 (HTTP) n√£o permitida"
            fi
        else
            warn "UFW n√£o est√° ativo"
        fi
    else
        warn "UFW n√£o instalado"
    fi
}

# Fun√ß√£o para verificar logs
check_logs() {
    info "Verificando logs..."
    
    LOG_DIR="/var/log/$APP_NAME"
    
    if [ -d "$LOG_DIR" ]; then
        log "Diret√≥rio de logs encontrado: $LOG_DIR"
        
        # Verificar arquivos de log
        for log_file in error.log out.log combined.log; do
            if [ -f "$LOG_DIR/$log_file" ]; then
                size=$(du -h "$LOG_DIR/$log_file" | cut -f1)
                log "Log $log_file encontrado ($size)"
                
                # Verificar se h√° erros recentes
                if [ "$log_file" = "error.log" ]; then
                    error_count=$(sudo tail -100 "$LOG_DIR/$log_file" | grep -c "ERROR\|error" 2>/dev/null || echo "0")
                    if [ "$error_count" -gt 0 ]; then
                        warn "Encontrados $error_count erros recentes no log"
                    else
                        log "Nenhum erro recente encontrado"
                    fi
                fi
            else
                warn "Log $log_file n√£o encontrado"
            fi
        done
    else
        warn "Diret√≥rio de logs n√£o encontrado"
    fi
}

# Fun√ß√£o para verificar recursos do sistema
check_system_resources() {
    info "Verificando recursos do sistema..."
    
    # CPU
    cpu_usage=$(top -bn1 | grep "Cpu(s)" | awk '{print $2}' | cut -d'%' -f1)
    log "Uso de CPU: ${cpu_usage}%"
    
    # Mem√≥ria
    memory_info=$(free -m | awk 'NR==2{printf "%.1f%%", $3*100/$2}')
    log "Uso de mem√≥ria: $memory_info"
    
    # Disco
    disk_usage=$(df -h / | awk 'NR==2{print $5}')
    log "Uso de disco: $disk_usage"
    
    # Verificar se h√° espa√ßo suficiente
    disk_available=$(df -BG / | awk 'NR==2{print $4}' | sed 's/G//')
    if [ "$disk_available" -lt 5 ]; then
        warn "Pouco espa√ßo em disco dispon√≠vel: ${disk_available}G"
    else
        log "Espa√ßo em disco OK: ${disk_available}G dispon√≠vel"
    fi
}

# Fun√ß√£o para testar API
test_api() {
    info "Testando API..."
    
    # Verificar se a aplica√ß√£o est√° respondendo
    if command -v curl &> /dev/null; then
        # Testar API com dom√≠nio configurado
        API_URL="http://$DOMAIN:$API_PORT"
        if curl -s -o /dev/null -w "%{http_code}" "$API_URL/api/health" | grep -q "200"; then
            log "API respondendo em $API_URL"
        else
            # Tentar com Nginx se dispon√≠vel
            if command -v nginx &> /dev/null; then
                DOMAIN=$(grep "server_name" /etc/nginx/sites-available/$APP_NAME 2>/dev/null | awk '{print $2}' | sed 's/;$//' || echo "")
                if [ -n "$DOMAIN" ] && curl -s -o /dev/null -w "%{http_code}" http://$DOMAIN/api/health | grep -q "200"; then
                    log "API respondendo via Nginx: $DOMAIN"
                    API_URL="http://$DOMAIN"
                else
                    error "API n√£o est√° respondendo"
                    return 1
                fi
            else
                error "API n√£o est√° respondendo"
                return 1
            fi
        fi
        
        # Testar endpoints espec√≠ficos
        if [ -n "$API_URL" ]; then
            # Teste de health
            if curl -s "$API_URL/api/health" | grep -q "status.*ok"; then
                log "Endpoint /api/health OK"
            else
                warn "Endpoint /api/health com problema"
            fi
            
            # Teste de eventos (pode retornar 401 se n√£o autenticado, mas deve responder)
            HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" "$API_URL/api/events")
            if [ "$HTTP_CODE" = "200" ] || [ "$HTTP_CODE" = "401" ]; then
                log "Endpoint /api/events respondendo (HTTP $HTTP_CODE)"
            else
                warn "Endpoint /api/events com problema (HTTP $HTTP_CODE)"
            fi
        fi
    else
        warn "curl n√£o instalado - n√£o foi poss√≠vel testar API"
    fi
}

# Fun√ß√£o para verificar backups
check_backups() {
    info "Verificando backups..."
    
    BACKUP_DIR="/var/backups/$APP_NAME"
    
    if [ -d "$BACKUP_DIR" ]; then
        log "Diret√≥rio de backups encontrado: $BACKUP_DIR"
        
        # Contar backups
        backup_count=$(ls -1 $BACKUP_DIR/*.gz 2>/dev/null | wc -l)
        if [ "$backup_count" -gt 0 ]; then
            log "Encontrados $backup_count backups"
            
            # Verificar backup mais recente
            latest_backup=$(ls -t $BACKUP_DIR/*.gz 2>/dev/null | head -1)
            if [ -n "$latest_backup" ]; then
                backup_date=$(stat -c %y "$latest_backup" | cut -d' ' -f1)
                log "Backup mais recente: $(basename $latest_backup) ($backup_date)"
            fi
        else
            warn "Nenhum backup encontrado"
        fi
    else
        warn "Diret√≥rio de backups n√£o encontrado"
    fi
}

# Fun√ß√£o para mostrar resumo
show_summary() {
    echo ""
    echo -e "${BLUE}‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê${NC}"
    echo -e "${BLUE}                    RESUMO DO HEALTH CHECK                    ${NC}"
    echo -e "${BLUE}‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê${NC}"
    echo ""
    
    # Contar problemas
    local errors=0
    local warnings=0
    
    # Verificar se houve erros
    if [ $? -ne 0 ]; then
        errors=$((errors + 1))
    fi
    
    echo -e "${GREEN}‚úì Componentes verificados com sucesso${NC}"
    echo -e "${YELLOW}‚ö† Avisos e recomenda√ß√µes${NC}"
    echo -e "${RED}‚úó Problemas encontrados${NC}"
    
    echo ""
    echo -e "${BLUE}üîß Pr√≥ximos passos recomendados:${NC}"
    
    if [ $errors -gt 0 ]; then
        echo "  ‚Ä¢ Corrija os problemas identificados"
        echo "  ‚Ä¢ Execute o script novamente ap√≥s as corre√ß√µes"
    fi
    
    echo "  ‚Ä¢ Configure monitoramento cont√≠nuo"
    echo "  ‚Ä¢ Configure backup autom√°tico"
    echo "  ‚Ä¢ Monitore logs regularmente"
    echo "  ‚Ä¢ Mantenha o sistema atualizado"
    
    echo ""
    echo -e "${BLUE}üìû Comandos √∫teis:${NC}"
    echo "  ‚Ä¢ Status da aplica√ß√£o: sudo just-dance-hub status"
    echo "  ‚Ä¢ Ver logs: sudo just-dance-hub logs"
    echo "  ‚Ä¢ Reiniciar: sudo just-dance-hub restart"
    echo "  ‚Ä¢ Backup: ./backup-ubuntu.sh"
    
    echo ""
    log "Health check conclu√≠do!"
}

# Fun√ß√£o principal
main() {
    info "Iniciando health check do Just Dance Event Hub..."
    
    # Executar verifica√ß√µes
    check_installation
    check_system_user
    check_postgresql
    check_pm2
    check_nginx
    check_firewall
    check_logs
    check_system_resources
    test_api
    check_backups
    
    # Mostrar resumo
    show_summary
}

# Executar fun√ß√£o principal
main "$@"